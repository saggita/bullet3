//this file is autogenerated using stringify.bat (premake --stringify) in the build folder of this project
static const char* satClipKernelsCL= \
"\n"
"#define TRIANGLE_NUM_CONVEX_FACES 5\n"
"\n"
"#define SHAPE_CONVEX_HULL 3\n"
"#define SHAPE_PLANE 4\n"
"#define SHAPE_CONCAVE_TRIMESH 5\n"
"#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\n"
"#define SHAPE_SPHERE 7\n"
"\n"
"\n"
"#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable\n"
"\n"
"#ifdef cl_ext_atomic_counters_32\n"
"#pragma OPENCL EXTENSION cl_ext_atomic_counters_32 : enable\n"
"#else\n"
"#define counter32_t volatile __global int*\n"
"#endif\n"
"\n"
"#define GET_GROUP_IDX get_group_id(0)\n"
"#define GET_LOCAL_IDX get_local_id(0)\n"
"#define GET_GLOBAL_IDX get_global_id(0)\n"
"#define GET_GROUP_SIZE get_local_size(0)\n"
"#define GET_NUM_GROUPS get_num_groups(0)\n"
"#define GROUP_LDS_BARRIER barrier(CLK_LOCAL_MEM_FENCE)\n"
"#define GROUP_MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE)\n"
"#define AtomInc(x) atom_inc(&(x))\n"
"#define AtomInc1(x, out) out = atom_inc(&(x))\n"
"#define AppendInc(x, out) out = atomic_inc(x)\n"
"#define AtomAdd(x, value) atom_add(&(x), value)\n"
"#define AtomCmpxhg(x, cmp, value) atom_cmpxchg( &(x), cmp, value )\n"
"#define AtomXhg(x, value) atom_xchg ( &(x), value )\n"
"\n"
"#define max2 max\n"
"#define min2 min\n"
"\n"
"typedef unsigned int u32;\n"
"\n"
"\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_worldPos[4];\n"
"	float4 m_worldNormal;	//	w: m_nPoints\n"
"	u32 m_coeffs;\n"
"	u32 m_batchIdx;\n"
"\n"
"	int m_bodyAPtrAndSignBit;//x:m_bodyAPtr, y:m_bodyBPtr\n"
"	int m_bodyBPtrAndSignBit;\n"
"} Contact4;\n"
"\n"
"\n"
"///keep this in sync with btCollidable.h\n"
"typedef struct\n"
"{\n"
"	int m_numChildShapes;\n"
"	float m_radius;\n"
"	int m_shapeType;\n"
"	int m_shapeIndex;\n"
"	\n"
"} btCollidableGpu;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4	m_childPosition;\n"
"	float4	m_childOrientation;\n"
"	int m_shapeIndex;\n"
"	int m_unused0;\n"
"	int m_unused1;\n"
"	int m_unused2;\n"
"} btGpuChildShape;\n"
"\n"
"#define GET_NPOINTS(x) (x).m_worldNormal.w\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_pos;\n"
"	float4 m_quat;\n"
"	float4 m_linVel;\n"
"	float4 m_angVel;\n"
"\n"
"	u32 m_collidableIdx;	\n"
"	float m_invMass;\n"
"	float m_restituitionCoeff;\n"
"	float m_frictionCoeff;\n"
"} BodyData;\n"
"\n"
"\n"
"typedef struct  \n"
"{\n"
"	float4		m_localCenter;\n"
"	float4		m_extents;\n"
"	float4		mC;\n"
"	float4		mE;\n"
"	\n"
"	float			m_radius;\n"
"	int	m_faceOffset;\n"
"	int m_numFaces;\n"
"	int	m_numVertices;\n"
"	\n"
"	int m_vertexOffset;\n"
"	int	m_uniqueEdgesOffset;\n"
"	int	m_numUniqueEdges;\n"
"	int m_unused;\n"
"\n"
"} ConvexPolyhedronCL;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_plane;\n"
"	int m_indexOffset;\n"
"	int m_numIndices;\n"
"} btGpuFace;\n"
"\n"
"#define SELECT_UINT4( b, a, condition ) select( b,a,condition )\n"
"\n"
"#define make_float4 (float4)\n"
"#define make_float2 (float2)\n"
"#define make_uint4 (uint4)\n"
"#define make_int4 (int4)\n"
"#define make_uint2 (uint2)\n"
"#define make_int2 (int2)\n"
"\n"
"\n"
"__inline\n"
"float fastDiv(float numerator, float denominator)\n"
"{\n"
"	return native_divide(numerator, denominator);	\n"
"//	return numerator/denominator;	\n"
"}\n"
"\n"
"__inline\n"
"float4 fastDiv4(float4 numerator, float4 denominator)\n"
"{\n"
"	return native_divide(numerator, denominator);	\n"
"}\n"
"\n"
"\n"
"__inline\n"
"float4 cross3(float4 a, float4 b)\n"
"{\n"
"	return cross(a,b);\n"
"}\n"
"\n"
"//#define dot3F4 dot\n"
"\n"
"__inline\n"
"float dot3F4(float4 a, float4 b)\n"
"{\n"
"	float4 a1 = make_float4(a.xyz,0.f);\n"
"	float4 b1 = make_float4(b.xyz,0.f);\n"
"	return dot(a1, b1);\n"
"}\n"
"\n"
"__inline\n"
"float4 fastNormalize4(float4 v)\n"
"{\n"
"	return fast_normalize(v);\n"
"}\n"
"\n"
"\n"
"///////////////////////////////////////\n"
"//	Quaternion\n"
"///////////////////////////////////////\n"
"\n"
"typedef float4 Quaternion;\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b);\n"
"\n"
"__inline\n"
"Quaternion qtNormalize(Quaternion in);\n"
"\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec);\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q);\n"
"\n"
"\n"
"\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b)\n"
"{\n"
"	Quaternion ans;\n"
"	ans = cross3( a, b );\n"
"	ans += a.w*b+b.w*a;\n"
"//	ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\n"
"	ans.w = a.w*b.w - dot3F4(a, b);\n"
"	return ans;\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtNormalize(Quaternion in)\n"
"{\n"
"	return fastNormalize4(in);\n"
"//	in /= length( in );\n"
"//	return in;\n"
"}\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec)\n"
"{\n"
"	Quaternion qInv = qtInvert( q );\n"
"	float4 vcpy = vec;\n"
"	vcpy.w = 0.f;\n"
"	float4 out = qtMul(qtMul(q,vcpy),qInv);\n"
"	return out;\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q)\n"
"{\n"
"	return (Quaternion)(-q.xyz, q.w);\n"
"}\n"
"\n"
"__inline\n"
"float4 qtInvRotate(const Quaternion q, float4 vec)\n"
"{\n"
"	return qtRotate( qtInvert( q ), vec );\n"
"}\n"
"\n"
"__inline\n"
"float4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\n"
"{\n"
"	return qtRotate( *orientation, *p ) + (*translation);\n"
"}\n"
"\n"
"\n"
"\n"
"__inline\n"
"float4 normalize3(const float4 a)\n"
"{\n"
"	float4 n = make_float4(a.x, a.y, a.z, 0.f);\n"
"	return fastNormalize4( n );\n"
"}\n"
"\n"
"\n"
"__inline float4 lerp3(const float4 a,const float4 b, float  t)\n"
"{\n"
"	return make_float4(	a.x + (b.x - a.x) * t,\n"
"						a.y + (b.y - a.y) * t,\n"
"						a.z + (b.z - a.z) * t,\n"
"						0.f);\n"
"}\n"
"\n"
"\n"
"\n"
"// Clips a face to the back of a plane, return the number of vertices out, stored in ppVtxOut\n"
"int clipFaceGlobal(__global const float4* pVtxIn, int numVertsIn, float4 planeNormalWS,float planeEqWS, __global float4* ppVtxOut)\n"
"{\n"
"	\n"
"	int ve;\n"
"	float ds, de;\n"
"	int numVertsOut = 0;\n"
"    //double-check next test\n"
"    //	if (numVertsIn < 2)\n"
"    //		return 0;\n"
"    \n"
"	float4 firstVertex=pVtxIn[numVertsIn-1];\n"
"	float4 endVertex = pVtxIn[0];\n"
"	\n"
"	ds = dot3F4(planeNormalWS,firstVertex)+planeEqWS;\n"
"    \n"
"	for (ve = 0; ve < numVertsIn; ve++)\n"
"	{\n"
"		endVertex=pVtxIn[ve];\n"
"		de = dot3F4(planeNormalWS,endVertex)+planeEqWS;\n"
"		if (ds<0)\n"
"		{\n"
"			if (de<0)\n"
"			{\n"
"				// Start < 0, end < 0, so output endVertex\n"
"				ppVtxOut[numVertsOut++] = endVertex;\n"
"			}\n"
"			else\n"
"			{\n"
"				// Start < 0, end >= 0, so output intersection\n"
"				ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\n"
"			}\n"
"		}\n"
"		else\n"
"		{\n"
"			if (de<0)\n"
"			{\n"
"				// Start >= 0, end < 0 so output intersection and end\n"
"				ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\n"
"				ppVtxOut[numVertsOut++] = endVertex;\n"
"			}\n"
"		}\n"
"		firstVertex = endVertex;\n"
"		ds = de;\n"
"	}\n"
"	return numVertsOut;\n"
"}\n"
"\n"
"\n"
"\n"
"// Clips a face to the back of a plane, return the number of vertices out, stored in ppVtxOut\n"
"int clipFace(const float4* pVtxIn, int numVertsIn, float4 planeNormalWS,float planeEqWS, float4* ppVtxOut)\n"
"{\n"
"	\n"
"	int ve;\n"
"	float ds, de;\n"
"	int numVertsOut = 0;\n"
"//double-check next test\n"
"//	if (numVertsIn < 2)\n"
"//		return 0;\n"
"\n"
"	float4 firstVertex=pVtxIn[numVertsIn-1];\n"
"	float4 endVertex = pVtxIn[0];\n"
"	\n"
"	ds = dot3F4(planeNormalWS,firstVertex)+planeEqWS;\n"
"\n"
"	for (ve = 0; ve < numVertsIn; ve++)\n"
"	{\n"
"		endVertex=pVtxIn[ve];\n"
"\n"
"		de = dot3F4(planeNormalWS,endVertex)+planeEqWS;\n"
"\n"
"		if (ds<0)\n"
"		{\n"
"			if (de<0)\n"
"			{\n"
"				// Start < 0, end < 0, so output endVertex\n"
"				ppVtxOut[numVertsOut++] = endVertex;\n"
"			}\n"
"			else\n"
"			{\n"
"				// Start < 0, end >= 0, so output intersection\n"
"				ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\n"
"			}\n"
"		}\n"
"		else\n"
"		{\n"
"			if (de<0)\n"
"			{\n"
"				// Start >= 0, end < 0 so output intersection and end\n"
"				ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\n"
"				ppVtxOut[numVertsOut++] = endVertex;\n"
"			}\n"
"		}\n"
"		firstVertex = endVertex;\n"
"		ds = de;\n"
"	}\n"
"	return numVertsOut;\n"
"}\n"
"\n"
"\n"
"int clipFaceAgainstHull(const float4 separatingNormal, __global const ConvexPolyhedronCL* hullA,  \n"
"	const float4 posA, const Quaternion ornA, float4* worldVertsB1, int numWorldVertsB1,\n"
"	float4* worldVertsB2, int capacityWorldVertsB2,\n"
"	const float minDist, float maxDist,\n"
"	__global const float4* vertices,\n"
"	__global const btGpuFace* faces,\n"
"	__global const int* indices,\n"
"	float4* contactsOut,\n"
"	int contactCapacity)\n"
"{\n"
"	int numContactsOut = 0;\n"
"\n"
"	float4* pVtxIn = worldVertsB1;\n"
"	float4* pVtxOut = worldVertsB2;\n"
"	\n"
"	int numVertsIn = numWorldVertsB1;\n"
"	int numVertsOut = 0;\n"
"\n"
"	int closestFaceA=-1;\n"
"	{\n"
"		float dmin = FLT_MAX;\n"
"		for(int face=0;face<hullA->m_numFaces;face++)\n"
"		{\n"
"			const float4 Normal = make_float4(\n"
"				faces[hullA->m_faceOffset+face].m_plane.x, \n"
"				faces[hullA->m_faceOffset+face].m_plane.y, \n"
"				faces[hullA->m_faceOffset+face].m_plane.z,0.f);\n"
"			const float4 faceANormalWS = qtRotate(ornA,Normal);\n"
"		\n"
"			float d = dot3F4(faceANormalWS,separatingNormal);\n"
"			if (d < dmin)\n"
"			{\n"
"				dmin = d;\n"
"				closestFaceA = face;\n"
"			}\n"
"		}\n"
"	}\n"
"	if (closestFaceA<0)\n"
"		return numContactsOut;\n"
"\n"
"	btGpuFace polyA = faces[hullA->m_faceOffset+closestFaceA];\n"
"\n"
"	// clip polygon to back of planes of all faces of hull A that are adjacent to witness face\n"
"	int numVerticesA = polyA.m_numIndices;\n"
"	for(int e0=0;e0<numVerticesA;e0++)\n"
"	{\n"
"		const float4 a = vertices[hullA->m_vertexOffset+indices[polyA.m_indexOffset+e0]];\n"
"		const float4 b = vertices[hullA->m_vertexOffset+indices[polyA.m_indexOffset+((e0+1)%numVerticesA)]];\n"
"		const float4 edge0 = a - b;\n"
"		const float4 WorldEdge0 = qtRotate(ornA,edge0);\n"
"		float4 planeNormalA = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\n"
"		float4 worldPlaneAnormal1 = qtRotate(ornA,planeNormalA);\n"
"\n"
"		float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\n"
"		float4 worldA1 = transform(&a,&posA,&ornA);\n"
"		float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\n"
"		\n"
"		float4 planeNormalWS = planeNormalWS1;\n"
"		float planeEqWS=planeEqWS1;\n"
"		\n"
"		//clip face\n"
"		//clipFace(*pVtxIn, *pVtxOut,planeNormalWS,planeEqWS);\n"
"		numVertsOut = clipFace(pVtxIn, numVertsIn, planeNormalWS,planeEqWS, pVtxOut);\n"
"\n"
"		//btSwap(pVtxIn,pVtxOut);\n"
"		float4* tmp = pVtxOut;\n"
"		pVtxOut = pVtxIn;\n"
"		pVtxIn = tmp;\n"
"		numVertsIn = numVertsOut;\n"
"		numVertsOut = 0;\n"
"	}\n"
"\n"
"	\n"
"	// only keep points that are behind the witness face\n"
"	{\n"
"		float4 localPlaneNormal  = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\n"
"		float localPlaneEq = polyA.m_plane.w;\n"
"		float4 planeNormalWS = qtRotate(ornA,localPlaneNormal);\n"
"		float planeEqWS=localPlaneEq-dot3F4(planeNormalWS,posA);\n"
"		for (int i=0;i<numVertsIn;i++)\n"
"		{\n"
"			float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\n"
"			if (depth <=minDist)\n"
"			{\n"
"				depth = minDist;\n"
"			}\n"
"\n"
"			if (depth <=maxDist)\n"
"			{\n"
"				float4 pointInWorld = pVtxIn[i];\n"
"				//resultOut.addContactPoint(separatingNormal,point,depth);\n"
"				contactsOut[numContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	return numContactsOut;\n"
"}\n"
"\n"
"\n"
"\n"
"int clipFaceAgainstHullLocalA(const float4 separatingNormal, const ConvexPolyhedronCL* hullA,  \n"
"	const float4 posA, const Quaternion ornA, float4* worldVertsB1, int numWorldVertsB1,\n"
"	float4* worldVertsB2, int capacityWorldVertsB2,\n"
"	const float minDist, float maxDist,\n"
"	const float4* verticesA,\n"
"	const btGpuFace* facesA,\n"
"	const int* indicesA,\n"
"	__global const float4* verticesB,\n"
"	__global const btGpuFace* facesB,\n"
"	__global const int* indicesB,\n"
"	float4* contactsOut,\n"
"	int contactCapacity)\n"
"{\n"
"	int numContactsOut = 0;\n"
"\n"
"	float4* pVtxIn = worldVertsB1;\n"
"	float4* pVtxOut = worldVertsB2;\n"
"	\n"
"	int numVertsIn = numWorldVertsB1;\n"
"	int numVertsOut = 0;\n"
"\n"
"	int closestFaceA=-1;\n"
"	{\n"
"		float dmin = FLT_MAX;\n"
"		for(int face=0;face<hullA->m_numFaces;face++)\n"
"		{\n"
"			const float4 Normal = make_float4(\n"
"				facesA[hullA->m_faceOffset+face].m_plane.x, \n"
"				facesA[hullA->m_faceOffset+face].m_plane.y, \n"
"				facesA[hullA->m_faceOffset+face].m_plane.z,0.f);\n"
"			const float4 faceANormalWS = qtRotate(ornA,Normal);\n"
"		\n"
"			float d = dot3F4(faceANormalWS,separatingNormal);\n"
"			if (d < dmin)\n"
"			{\n"
"				dmin = d;\n"
"				closestFaceA = face;\n"
"			}\n"
"		}\n"
"	}\n"
"	if (closestFaceA<0)\n"
"		return numContactsOut;\n"
"\n"
"	btGpuFace polyA = facesA[hullA->m_faceOffset+closestFaceA];\n"
"\n"
"	// clip polygon to back of planes of all faces of hull A that are adjacent to witness face\n"
"	int numVerticesA = polyA.m_numIndices;\n"
"	for(int e0=0;e0<numVerticesA;e0++)\n"
"	{\n"
"		const float4 a = verticesA[hullA->m_vertexOffset+indicesA[polyA.m_indexOffset+e0]];\n"
"		const float4 b = verticesA[hullA->m_vertexOffset+indicesA[polyA.m_indexOffset+((e0+1)%numVerticesA)]];\n"
"		const float4 edge0 = a - b;\n"
"		const float4 WorldEdge0 = qtRotate(ornA,edge0);\n"
"		float4 planeNormalA = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\n"
"		float4 worldPlaneAnormal1 = qtRotate(ornA,planeNormalA);\n"
"\n"
"		float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\n"
"		float4 worldA1 = transform(&a,&posA,&ornA);\n"
"		float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\n"
"		\n"
"		float4 planeNormalWS = planeNormalWS1;\n"
"		float planeEqWS=planeEqWS1;\n"
"		\n"
"		//clip face\n"
"		//clipFace(*pVtxIn, *pVtxOut,planeNormalWS,planeEqWS);\n"
"		numVertsOut = clipFace(pVtxIn, numVertsIn, planeNormalWS,planeEqWS, pVtxOut);\n"
"\n"
"		//btSwap(pVtxIn,pVtxOut);\n"
"		float4* tmp = pVtxOut;\n"
"		pVtxOut = pVtxIn;\n"
"		pVtxIn = tmp;\n"
"		numVertsIn = numVertsOut;\n"
"		numVertsOut = 0;\n"
"	}\n"
"\n"
"	\n"
"	// only keep points that are behind the witness face\n"
"	{\n"
"		float4 localPlaneNormal  = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\n"
"		float localPlaneEq = polyA.m_plane.w;\n"
"		float4 planeNormalWS = qtRotate(ornA,localPlaneNormal);\n"
"		float planeEqWS=localPlaneEq-dot3F4(planeNormalWS,posA);\n"
"		for (int i=0;i<numVertsIn;i++)\n"
"		{\n"
"			float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\n"
"			if (depth <=minDist)\n"
"			{\n"
"				depth = minDist;\n"
"			}\n"
"\n"
"			if (depth <=maxDist)\n"
"			{\n"
"				float4 pointInWorld = pVtxIn[i];\n"
"				//resultOut.addContactPoint(separatingNormal,point,depth);\n"
"				contactsOut[numContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	return numContactsOut;\n"
"}\n"
"\n"
"int	clipHullAgainstHull(const float4 separatingNormal,\n"
"	__global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \n"
"	const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB, \n"
"	float4* worldVertsB1, float4* worldVertsB2, int capacityWorldVerts,\n"
"	const float minDist, float maxDist,\n"
"	__global const float4* vertices,\n"
"	__global const btGpuFace* faces,\n"
"	__global const int* indices,\n"
"	float4*	localContactsOut,\n"
"	int localContactCapacity)\n"
"{\n"
"	int numContactsOut = 0;\n"
"	int numWorldVertsB1= 0;\n"
"\n"
"\n"
"	int closestFaceB=-1;\n"
"	float dmax = -FLT_MAX;\n"
"\n"
"	{\n"
"		for(int face=0;face<hullB->m_numFaces;face++)\n"
"		{\n"
"			const float4 Normal = make_float4(faces[hullB->m_faceOffset+face].m_plane.x, \n"
"				faces[hullB->m_faceOffset+face].m_plane.y, faces[hullB->m_faceOffset+face].m_plane.z,0.f);\n"
"			const float4 WorldNormal = qtRotate(ornB, Normal);\n"
"			float d = dot3F4(WorldNormal,separatingNormal);\n"
"			if (d > dmax)\n"
"			{\n"
"				dmax = d;\n"
"				closestFaceB = face;\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	{\n"
"		const btGpuFace polyB = faces[hullB->m_faceOffset+closestFaceB];\n"
"		const int numVertices = polyB.m_numIndices;\n"
"		for(int e0=0;e0<numVertices;e0++)\n"
"		{\n"
"			const float4 b = vertices[hullB->m_vertexOffset+indices[polyB.m_indexOffset+e0]];\n"
"			worldVertsB1[numWorldVertsB1++] = transform(&b,&posB,&ornB);\n"
"		}\n"
"	}\n"
"\n"
"	if (closestFaceB>=0)\n"
"	{\n"
"		numContactsOut = clipFaceAgainstHull(separatingNormal, hullA, \n"
"				posA,ornA,\n"
"				worldVertsB1,numWorldVertsB1,worldVertsB2,capacityWorldVerts, minDist, maxDist,vertices,\n"
"				faces,\n"
"				indices,localContactsOut,localContactCapacity);\n"
"	}\n"
"\n"
"	return numContactsOut;\n"
"}\n"
"\n"
"\n"
"int	clipHullAgainstHullLocalA(const float4 separatingNormal,\n"
"	const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \n"
"	const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB, \n"
"	float4* worldVertsB1, float4* worldVertsB2, int capacityWorldVerts,\n"
"	const float minDist, float maxDist,\n"
"	const float4* verticesA,\n"
"	const btGpuFace* facesA,\n"
"	const int* indicesA,\n"
"	__global const float4* verticesB,\n"
"	__global const btGpuFace* facesB,\n"
"	__global const int* indicesB,\n"
"	float4*	localContactsOut,\n"
"	int localContactCapacity)\n"
"{\n"
"	int numContactsOut = 0;\n"
"	int numWorldVertsB1= 0;\n"
"\n"
"\n"
"	int closestFaceB=-1;\n"
"	float dmax = -FLT_MAX;\n"
"\n"
"	{\n"
"		for(int face=0;face<hullB->m_numFaces;face++)\n"
"		{\n"
"			const float4 Normal = make_float4(facesB[hullB->m_faceOffset+face].m_plane.x, \n"
"				facesB[hullB->m_faceOffset+face].m_plane.y, facesB[hullB->m_faceOffset+face].m_plane.z,0.f);\n"
"			const float4 WorldNormal = qtRotate(ornB, Normal);\n"
"			float d = dot3F4(WorldNormal,separatingNormal);\n"
"			if (d > dmax)\n"
"			{\n"
"				dmax = d;\n"
"				closestFaceB = face;\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	{\n"
"		const btGpuFace polyB = facesB[hullB->m_faceOffset+closestFaceB];\n"
"		const int numVertices = polyB.m_numIndices;\n"
"		for(int e0=0;e0<numVertices;e0++)\n"
"		{\n"
"			const float4 b = verticesB[hullB->m_vertexOffset+indicesB[polyB.m_indexOffset+e0]];\n"
"			worldVertsB1[numWorldVertsB1++] = transform(&b,&posB,&ornB);\n"
"		}\n"
"	}\n"
"\n"
"	if (closestFaceB>=0)\n"
"	{\n"
"		numContactsOut = clipFaceAgainstHullLocalA(separatingNormal, hullA, \n"
"				posA,ornA,\n"
"				worldVertsB1,numWorldVertsB1,worldVertsB2,capacityWorldVerts, minDist, maxDist,\n"
"				verticesA,facesA,indicesA,\n"
"				verticesB,facesB,indicesB,\n"
"				localContactsOut,localContactCapacity);\n"
"	}\n"
"\n"
"	return numContactsOut;\n"
"}\n"
"\n"
"#define PARALLEL_SUM(v, n) for(int j=1; j<n; j++) v[0] += v[j];\n"
"#define PARALLEL_DO(execution, n) for(int ie=0; ie<n; ie++){execution;}\n"
"#define REDUCE_MAX(v, n) {int i=0;"
"for(int offset=0; offset<n; offset++) v[i] = (v[i].y > v[i+offset].y)? v[i]: v[i+offset]; }\n"
"#define REDUCE_MIN(v, n) {int i=0;"
"for(int offset=0; offset<n; offset++) v[i] = (v[i].y < v[i+offset].y)? v[i]: v[i+offset]; }\n"
"\n"
"int extractManifoldSequentialGlobal(__global const float4* p, int nPoints, float4 nearNormal, int4* contactIdx)\n"
"{\n"
"	if( nPoints == 0 )\n"
"        return 0;\n"
"    \n"
"    if (nPoints <=4)\n"
"        return nPoints;\n"
"    \n"
"    \n"
"    if (nPoints >64)\n"
"        nPoints = 64;\n"
"    \n"
"	float4 center = make_float4(0.f);\n"
"	{\n"
"		\n"
"		for (int i=0;i<nPoints;i++)\n"
"			center += p[i];\n"
"		center /= (float)nPoints;\n"
"	}\n"
"    \n"
"	\n"
"    \n"
"	//	sample 4 directions\n"
"    \n"
"    float4 aVector = p[0] - center;\n"
"    float4 u = cross3( nearNormal, aVector );\n"
"    float4 v = cross3( nearNormal, u );\n"
"    u = normalize3( u );\n"
"    v = normalize3( v );\n"
"    \n"
"    \n"
"    //keep point with deepest penetration\n"
"    float minW= FLT_MAX;\n"
"    \n"
"    int minIndex=-1;\n"
"    \n"
"    float4 maxDots;\n"
"    maxDots.x = FLT_MIN;\n"
"    maxDots.y = FLT_MIN;\n"
"    maxDots.z = FLT_MIN;\n"
"    maxDots.w = FLT_MIN;\n"
"    \n"
"    //	idx, distance\n"
"    for(int ie = 0; ie<nPoints; ie++ )\n"
"    {\n"
"        if (p[ie].w<minW)\n"
"        {\n"
"            minW = p[ie].w;\n"
"            minIndex=ie;\n"
"        }\n"
"        float f;\n"
"        float4 r = p[ie]-center;\n"
"        f = dot3F4( u, r );\n"
"        if (f<maxDots.x)\n"
"        {\n"
"            maxDots.x = f;\n"
"            contactIdx[0].x = ie;\n"
"        }\n"
"        \n"
"        f = dot3F4( -u, r );\n"
"        if (f<maxDots.y)\n"
"        {\n"
"            maxDots.y = f;\n"
"            contactIdx[0].y = ie;\n"
"        }\n"
"        \n"
"        \n"
"        f = dot3F4( v, r );\n"
"        if (f<maxDots.z)\n"
"        {\n"
"            maxDots.z = f;\n"
"            contactIdx[0].z = ie;\n"
"        }\n"
"        \n"
"        f = dot3F4( -v, r );\n"
"        if (f<maxDots.w)\n"
"        {\n"
"            maxDots.w = f;\n"
"            contactIdx[0].w = ie;\n"
"        }\n"
"        \n"
"    }\n"
"    \n"
"    if (contactIdx[0].x != minIndex && contactIdx[0].y != minIndex && contactIdx[0].z != minIndex && contactIdx[0].w != minIndex)\n"
"    {\n"
"        //replace the first contact with minimum (todo: replace contact with least penetration)\n"
"        contactIdx[0].x = minIndex;\n"
"    }\n"
"    \n"
"    return 4;\n"
"    \n"
"}\n"
"\n"
"\n"
"int extractManifoldSequentialGlobalFake(__global const float4* p, int nPoints, float4 nearNormal, int* contactIdx)\n"
"{\n"
"    contactIdx[0] = 0;\n"
"    contactIdx[1] = 1;\n"
"    contactIdx[2] = 2;\n"
"    contactIdx[3] = 3;\n"
"    \n"
"	if( nPoints == 0 ) return 0;\n"
"    \n"
"	nPoints = min2( nPoints, 4 );\n"
"    return nPoints;\n"
"    \n"
"}\n"
"\n"
"\n"
"\n"
"int extractManifoldSequential(const float4* p, int nPoints, float4 nearNormal, int* contactIdx)\n"
"{\n"
"	if( nPoints == 0 ) return 0;\n"
"\n"
"	nPoints = min2( nPoints, 64 );\n"
"\n"
"	float4 center = make_float4(0.f);\n"
"	{\n"
"		float4 v[64];\n"
"		for (int i=0;i<nPoints;i++)\n"
"			v[i] = p[i];\n"
"		//memcpy( v, p, nPoints*sizeof(float4) );\n"
"		PARALLEL_SUM( v, nPoints );\n"
"		center = v[0]/(float)nPoints;\n"
"	}\n"
"\n"
"	\n"
"\n"
"	{	//	sample 4 directions\n"
"		if( nPoints < 4 )\n"
"		{\n"
"			for(int i=0; i<nPoints; i++) \n"
"				contactIdx[i] = i;\n"
"			return nPoints;\n"
"		}\n"
"\n"
"		float4 aVector = p[0] - center;\n"
"		float4 u = cross3( nearNormal, aVector );\n"
"		float4 v = cross3( nearNormal, u );\n"
"		u = normalize3( u );\n"
"		v = normalize3( v );\n"
"\n"
"		int idx[4];\n"
"\n"
"		float2 max00 = make_float2(0,FLT_MAX);\n"
"		{\n"
"			//	idx, distance\n"
"			{\n"
"				{\n"
"					int4 a[64];\n"
"					for(int ie = 0; ie<nPoints; ie++ )\n"
"					{\n"
"						\n"
"						\n"
"						float f;\n"
"						float4 r = p[ie]-center;\n"
"						f = dot3F4( u, r );\n"
"						a[ie].x = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\n"
"\n"
"						f = dot3F4( -u, r );\n"
"						a[ie].y = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\n"
"\n"
"						f = dot3F4( v, r );\n"
"						a[ie].z = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\n"
"\n"
"						f = dot3F4( -v, r );\n"
"						a[ie].w = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\n"
"					}\n"
"\n"
"					for(int ie=0; ie<nPoints; ie++)\n"
"					{\n"
"						a[0].x = (a[0].x > a[ie].x )? a[0].x: a[ie].x;\n"
"						a[0].y = (a[0].y > a[ie].y )? a[0].y: a[ie].y;\n"
"						a[0].z = (a[0].z > a[ie].z )? a[0].z: a[ie].z;\n"
"						a[0].w = (a[0].w > a[ie].w )? a[0].w: a[ie].w;\n"
"					}\n"
"\n"
"					idx[0] = (int)a[0].x & 0xff;\n"
"					idx[1] = (int)a[0].y & 0xff;\n"
"					idx[2] = (int)a[0].z & 0xff;\n"
"					idx[3] = (int)a[0].w & 0xff;\n"
"				}\n"
"			}\n"
"\n"
"			{\n"
"				float2 h[64];\n"
"				PARALLEL_DO( h[ie] = make_float2((float)ie, p[ie].w), nPoints );\n"
"				REDUCE_MIN( h, nPoints );\n"
"				max00 = h[0];\n"
"			}\n"
"		}\n"
"\n"
"		contactIdx[0] = idx[0];\n"
"		contactIdx[1] = idx[1];\n"
"		contactIdx[2] = idx[2];\n"
"		contactIdx[3] = idx[3];\n"
"\n"
"\n"
"		return 4;\n"
"	}\n"
"}\n"
"\n"
"\n"
"\n"
"__kernel void   extractManifoldAndAddContactKernel(__global const int2* pairs, \n"
"																	__global const BodyData* rigidBodies, \n"
"																	__global const float4* closestPointsWorld,\n"
"																	__global const float4* separatingNormalsWorld,\n"
"																	__global const int* contactCounts,\n"
"																	__global const int* contactOffsets,\n"
"																	__global Contact4* restrict contactsOut,\n"
"																	counter32_t nContactsOut,\n"
"																	int numPairs,\n"
"																	int pairIndex\n"
"																	)\n"
"{\n"
"	int idx = get_global_id(0);\n"
"	\n"
"	if (idx<numPairs)\n"
"	{\n"
"		float4 normal = separatingNormalsWorld[idx];\n"
"		int nPoints = contactCounts[idx];\n"
"		__global const float4* pointsIn = &closestPointsWorld[contactOffsets[idx]];\n"
"		float4 localPoints[64];\n"
"		for (int i=0;i<nPoints;i++)\n"
"		{\n"
"			localPoints[i] = pointsIn[i];\n"
"		}\n"
"\n"
"		int contactIdx[4];// = {-1,-1,-1,-1};\n"
"		contactIdx[0] = -1;\n"
"		contactIdx[1] = -1;\n"
"		contactIdx[2] = -1;\n"
"		contactIdx[3] = -1;\n"
"\n"
"		int nContacts = extractManifoldSequential(localPoints, nPoints, normal, contactIdx);\n"
"\n"
"		int dstIdx;\n"
"		AppendInc( nContactsOut, dstIdx );\n"
"		//if ((dstIdx+nContacts) < capacity)\n"
"		{\n"
"			__global Contact4* c = contactsOut + dstIdx;\n"
"			c->m_worldNormal = normal;\n"
"			c->m_coeffs = (u32)(0.f*0xffff) | ((u32)(0.7f*0xffff)<<16);\n"
"			c->m_batchIdx = idx;\n"
"			int bodyA = pairs[pairIndex].x;\n"
"			int bodyB = pairs[pairIndex].y;\n"
"			c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0 ? -bodyA:bodyA;\n"
"			c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0 ? -bodyB:bodyB;\n"
"			for (int i=0;i<nContacts;i++)\n"
"			{\n"
"				c->m_worldPos[i] = localPoints[contactIdx[i]];\n"
"			}\n"
"			GET_NPOINTS(*c) = nContacts;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"\n"
"void	trInverse(float4 translationIn, Quaternion orientationIn,\n"
"		float4* translationOut, Quaternion* orientationOut)\n"
"{\n"
"	*orientationOut = qtInvert(orientationIn);\n"
"	*translationOut = qtRotate(*orientationOut, -translationIn);\n"
"}\n"
"\n"
"void	trMul(float4 translationA, Quaternion orientationA,\n"
"						float4 translationB, Quaternion orientationB,\n"
"		float4* translationOut, Quaternion* orientationOut)\n"
"{\n"
"	*orientationOut = qtMul(orientationA,orientationB);\n"
"	*translationOut = transform(&translationB,&translationA,&orientationA);\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"__kernel void   clipHullHullKernel( __global const int2* pairs, \n"
"																					__global const BodyData* rigidBodies, \n"
"																					__global const btCollidableGpu* collidables,\n"
"																					__global const ConvexPolyhedronCL* convexShapes, \n"
"																					__global const float4* vertices,\n"
"																					__global const float4* uniqueEdges,\n"
"																					__global const btGpuFace* faces,\n"
"																					__global const int* indices,\n"
"																					__global const float4* separatingNormals,\n"
"																					__global const int* hasSeparatingAxis,\n"
"																					__global Contact4* restrict globalContactsOut,\n"
"																					counter32_t nGlobalContactsOut,\n"
"																					int numPairs)\n"
"{\n"
"\n"
"	int i = get_global_id(0);\n"
"	int pairIndex = i;\n"
"	\n"
"	float4 worldVertsB1[64];\n"
"	float4 worldVertsB2[64];\n"
"	int capacityWorldVerts = 64;	\n"
"\n"
"	float4 localContactsOut[64];\n"
"	int localContactCapacity=64;\n"
"	\n"
"	float minDist = -1e30f;\n"
"	float maxDist = 0.02f;\n"
"\n"
"	if (i<numPairs)\n"
"	{\n"
"\n"
"		int bodyIndexA = pairs[i].x;\n"
"		int bodyIndexB = pairs[i].y;\n"
"			\n"
"		int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\n"
"		int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\n"
"\n"
"		if (hasSeparatingAxis[i])\n"
"		{\n"
"\n"
"			\n"
"			int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\n"
"			int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\n"
"			\n"
"\n"
"\n"
"		\n"
"			int numLocalContactsOut = clipHullAgainstHull(separatingNormals[i],\n"
"														&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],\n"
"														rigidBodies[bodyIndexA].m_pos,rigidBodies[bodyIndexA].m_quat,\n"
"													  rigidBodies[bodyIndexB].m_pos,rigidBodies[bodyIndexB].m_quat,\n"
"													  worldVertsB1,worldVertsB2,capacityWorldVerts,\n"
"														minDist, maxDist,\n"
"														vertices,faces,indices,\n"
"														localContactsOut,localContactCapacity);\n"
"												\n"
"		if (numLocalContactsOut>0)\n"
"		{\n"
"				float4 normal = -separatingNormals[i];\n"
"				int nPoints = numLocalContactsOut;\n"
"				float4* pointsIn = localContactsOut;\n"
"				int contactIdx[4];// = {-1,-1,-1,-1};\n"
"\n"
"				contactIdx[0] = -1;\n"
"				contactIdx[1] = -1;\n"
"				contactIdx[2] = -1;\n"
"				contactIdx[3] = -1;\n"
"		\n"
"				int nReducedContacts = extractManifoldSequential(pointsIn, nPoints, normal, contactIdx);\n"
"		\n"
"				int dstIdx;\n"
"				AppendInc( nGlobalContactsOut, dstIdx );\n"
"				//if ((dstIdx+nReducedContacts) < capacity)\n"
"				{\n"
"					__global Contact4* c = globalContactsOut+ dstIdx;\n"
"					c->m_worldNormal = normal;\n"
"					c->m_coeffs = (u32)(0.f*0xffff) | ((u32)(0.7f*0xffff)<<16);\n"
"					c->m_batchIdx = pairIndex;\n"
"					int bodyA = pairs[pairIndex].x;\n"
"					int bodyB = pairs[pairIndex].y;\n"
"					c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\n"
"					c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\n"
"\n"
"					for (int i=0;i<nReducedContacts;i++)\n"
"					{\n"
"						c->m_worldPos[i] = pointsIn[contactIdx[i]];\n"
"					}\n"
"					GET_NPOINTS(*c) = nReducedContacts;\n"
"				}\n"
"				\n"
"			}//		if (numContactsOut>0)\n"
"		}//		if (hasSeparatingAxis[i])\n"
"	}//	if (i<numPairs)\n"
"\n"
"}\n"
"\n"
"\n"
"__kernel void   clipCompoundsHullHullKernel( __global const int4* gpuCompoundPairs, \n"
"																					__global const BodyData* rigidBodies, \n"
"																					__global const btCollidableGpu* collidables,\n"
"																					__global const ConvexPolyhedronCL* convexShapes, \n"
"																					__global const float4* vertices,\n"
"																					__global const float4* uniqueEdges,\n"
"																					__global const btGpuFace* faces,\n"
"																					__global const int* indices,\n"
"																					__global const btGpuChildShape* gpuChildShapes,\n"
"																					__global const float4* gpuCompoundSepNormalsOut,\n"
"																					__global const int* gpuHasCompoundSepNormalsOut,\n"
"																					__global Contact4* restrict globalContactsOut,\n"
"																					counter32_t nGlobalContactsOut,\n"
"																					int numCompoundPairs, int maxContactCapacity)\n"
"{\n"
"\n"
"	int i = get_global_id(0);\n"
"	int pairIndex = i;\n"
"	\n"
"	float4 worldVertsB1[64];\n"
"	float4 worldVertsB2[64];\n"
"	int capacityWorldVerts = 64;	\n"
"\n"
"	float4 localContactsOut[64];\n"
"	int localContactCapacity=64;\n"
"	\n"
"	float minDist = -1e30f;\n"
"	float maxDist = 0.02f;\n"
"\n"
"	if (i<numCompoundPairs)\n"
"	{\n"
"\n"
"		if (gpuHasCompoundSepNormalsOut[i])\n"
"		{\n"
"\n"
"			int bodyIndexA = gpuCompoundPairs[i].x;\n"
"			int bodyIndexB = gpuCompoundPairs[i].y;\n"
"			\n"
"			int childShapeIndexA = gpuCompoundPairs[i].z;\n"
"			int childShapeIndexB = gpuCompoundPairs[i].w;\n"
"			\n"
"			int collidableIndexA = -1;\n"
"			int collidableIndexB = -1;\n"
"			\n"
"			float4 ornA = rigidBodies[bodyIndexA].m_quat;\n"
"			float4 posA = rigidBodies[bodyIndexA].m_pos;\n"
"			\n"
"			float4 ornB = rigidBodies[bodyIndexB].m_quat;\n"
"			float4 posB = rigidBodies[bodyIndexB].m_pos;\n"
"								\n"
"			if (childShapeIndexA >= 0)\n"
"			{\n"
"				collidableIndexA = gpuChildShapes[childShapeIndexA].m_shapeIndex;\n"
"				float4 childPosA = gpuChildShapes[childShapeIndexA].m_childPosition;\n"
"				float4 childOrnA = gpuChildShapes[childShapeIndexA].m_childOrientation;\n"
"				float4 newPosA = qtRotate(ornA,childPosA)+posA;\n"
"				float4 newOrnA = qtMul(ornA,childOrnA);\n"
"				posA = newPosA;\n"
"				ornA = newOrnA;\n"
"			} else\n"
"			{\n"
"				collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\n"
"			}\n"
"			\n"
"			if (childShapeIndexB>=0)\n"
"			{\n"
"				collidableIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\n"
"				float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\n"
"				float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\n"
"				float4 newPosB = transform(&childPosB,&posB,&ornB);\n"
"				float4 newOrnB = qtMul(ornB,childOrnB);\n"
"				posB = newPosB;\n"
"				ornB = newOrnB;\n"
"			} else\n"
"			{\n"
"				collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;	\n"
"			}\n"
"			\n"
"			int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\n"
"			int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\n"
"		\n"
"			int numLocalContactsOut = clipHullAgainstHull(gpuCompoundSepNormalsOut[i],\n"
"														&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],\n"
"														posA,ornA,\n"
"													  posB,ornB,\n"
"													  worldVertsB1,worldVertsB2,capacityWorldVerts,\n"
"														minDist, maxDist,\n"
"														vertices,faces,indices,\n"
"														localContactsOut,localContactCapacity);\n"
"												\n"
"		if (numLocalContactsOut>0)\n"
"		{\n"
"				float4 normal = -gpuCompoundSepNormalsOut[i];\n"
"				int nPoints = numLocalContactsOut;\n"
"				float4* pointsIn = localContactsOut;\n"
"				int contactIdx[4];// = {-1,-1,-1,-1};\n"
"\n"
"				contactIdx[0] = -1;\n"
"				contactIdx[1] = -1;\n"
"				contactIdx[2] = -1;\n"
"				contactIdx[3] = -1;\n"
"		\n"
"				int nReducedContacts = extractManifoldSequential(pointsIn, nPoints, normal, contactIdx);\n"
"		\n"
"				int dstIdx;\n"
"				AppendInc( nGlobalContactsOut, dstIdx );\n"
"				if ((dstIdx+nReducedContacts) < maxContactCapacity)\n"
"				{\n"
"					__global Contact4* c = globalContactsOut+ dstIdx;\n"
"					c->m_worldNormal = normal;\n"
"					c->m_coeffs = (u32)(0.f*0xffff) | ((u32)(0.7f*0xffff)<<16);\n"
"					c->m_batchIdx = pairIndex;\n"
"					int bodyA = gpuCompoundPairs[pairIndex].x;\n"
"					int bodyB = gpuCompoundPairs[pairIndex].y;\n"
"					c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\n"
"					c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\n"
"\n"
"					for (int i=0;i<nReducedContacts;i++)\n"
"					{\n"
"						c->m_worldPos[i] = pointsIn[contactIdx[i]];\n"
"					}\n"
"					GET_NPOINTS(*c) = nReducedContacts;\n"
"				}\n"
"				\n"
"			}//		if (numContactsOut>0)\n"
"		}//		if (gpuHasCompoundSepNormalsOut[i])\n"
"	}//	if (i<numCompoundPairs)\n"
"\n"
"}\n"
"\n"
"\n"
"\n"
"__kernel void   sphereSphereCollisionKernel( __global const int2* pairs, \n"
"																					__global const BodyData* rigidBodies, \n"
"																					__global const btCollidableGpu* collidables,\n"
"																					__global const float4* separatingNormals,\n"
"																					__global const int* hasSeparatingAxis,\n"
"																					__global Contact4* restrict globalContactsOut,\n"
"																					counter32_t nGlobalContactsOut,\n"
"																					int numPairs)\n"
"{\n"
"\n"
"	int i = get_global_id(0);\n"
"	int pairIndex = i;\n"
"	\n"
"	if (i<numPairs)\n"
"	{\n"
"		int bodyIndexA = pairs[i].x;\n"
"		int bodyIndexB = pairs[i].y;\n"
"			\n"
"		int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\n"
"		int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\n"
"\n"
"		if (collidables[collidableIndexA].m_shapeType == SHAPE_SPHERE &&\n"
"			collidables[collidableIndexB].m_shapeType == SHAPE_SPHERE)\n"
"		{\n"
"			//sphere-sphere\n"
"			float radiusA = collidables[collidableIndexA].m_radius;\n"
"			float radiusB = collidables[collidableIndexB].m_radius;\n"
"			float4 posA = rigidBodies[bodyIndexA].m_pos;\n"
"			float4 posB = rigidBodies[bodyIndexB].m_pos;\n"
"\n"
"			float4 diff = posA-posB;\n"
"			float len = length(diff);\n"
"			\n"
"			///iff distance positive, don't generate a new contact\n"
"			if ( len <= (radiusA+radiusB))\n"
"			{\n"
"				///distance (negative means penetration)\n"
"				float dist = len - (radiusA+radiusB);\n"
"				float4 normalOnSurfaceB = make_float4(1.f,0.f,0.f,0.f);\n"
"				if (len > 0.00001)\n"
"				{\n"
"					normalOnSurfaceB = diff / len;\n"
"				}\n"
"				float4 contactPosB = posB + normalOnSurfaceB*radiusB;\n"
"				contactPosB.w = dist;\n"
"								\n"
"				int dstIdx;\n"
"        AppendInc( nGlobalContactsOut, dstIdx );\n"
"				\n"
"				if (dstIdx < numPairs)\n"
"				{\n"
"					__global Contact4* c = &globalContactsOut[dstIdx];\n"
"					c->m_worldNormal = normalOnSurfaceB;\n"
"					c->m_coeffs = (u32)(0.f*0xffff) | ((u32)(0.7f*0xffff)<<16);\n"
"					c->m_batchIdx = pairIndex;\n"
"					int bodyA = pairs[pairIndex].x;\n"
"					int bodyB = pairs[pairIndex].y;\n"
"					c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\n"
"					c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\n"
"					c->m_worldPos[0] = contactPosB;\n"
"					GET_NPOINTS(*c) = 1;\n"
"				}//if (dstIdx < numPairs)\n"
"			}//if ( len <= (radiusA+radiusB))\n"
"		}//SHAPE_SPHERE SHAPE_SPHERE\n"
"	}//if (i<numPairs)\n"
"}				\n"
"\n"
"__kernel void   clipHullHullConcaveConvexKernel( __global int4* concavePairsIn,\n"
"																					__global const BodyData* rigidBodies, \n"
"																					__global const btCollidableGpu* collidables,\n"
"																					__global const ConvexPolyhedronCL* convexShapes, \n"
"																					__global const float4* vertices,\n"
"																					__global const float4* uniqueEdges,\n"
"																					__global const btGpuFace* faces,\n"
"																					__global const int* indices,\n"
"																					__global const btGpuChildShape* gpuChildShapes,\n"
"																					__global const float4* separatingNormals,\n"
"																					__global Contact4* restrict globalContactsOut,\n"
"																					counter32_t nGlobalContactsOut,\n"
"																					int numConcavePairs)\n"
"{\n"
"\n"
"	int i = get_global_id(0);\n"
"	int pairIndex = i;\n"
"	\n"
"	float4 worldVertsB1[64];\n"
"	float4 worldVertsB2[64];\n"
"	int capacityWorldVerts = 64;	\n"
"\n"
"	float4 localContactsOut[64];\n"
"	int localContactCapacity=64;\n"
"	\n"
"	float minDist = -1e30f;\n"
"	float maxDist = 0.02f;\n"
"\n"
"	if (i<numConcavePairs)\n"
"	{\n"
"		//negative value means that the pair is invalid\n"
"		if (concavePairsIn[i].w<0)\n"
"			return;\n"
"\n"
"		int bodyIndexA = concavePairsIn[i].x;\n"
"		int bodyIndexB = concavePairsIn[i].y;\n"
"		int f = concavePairsIn[i].z;\n"
"		\n"
"		int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\n"
"		int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\n"
"		\n"
"		int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\n"
"		int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\n"
"		\n"
"		///////////////////////////////////////////////////////////////\n"
"		\n"
"	\n"
"		bool overlap = false;\n"
"		\n"
"		ConvexPolyhedronCL convexPolyhedronA;\n"
"\n"
"	//add 3 vertices of the triangle\n"
"		convexPolyhedronA.m_numVertices = 3;\n"
"		convexPolyhedronA.m_vertexOffset = 0;\n"
"		float4	localCenter = make_float4(0.f,0.f,0.f,0.f);\n"
"\n"
"		btGpuFace face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\n"
"		\n"
"		float4 verticesA[3];\n"
"		for (int i=0;i<3;i++)\n"
"		{\n"
"			int index = indices[face.m_indexOffset+i];\n"
"			float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\n"
"			verticesA[i] = vert;\n"
"			localCenter += vert;\n"
"		}\n"
"\n"
"		float dmin = FLT_MAX;\n"
"\n"
"		int localCC=0;\n"
"\n"
"		//a triangle has 3 unique edges\n"
"		convexPolyhedronA.m_numUniqueEdges = 3;\n"
"		convexPolyhedronA.m_uniqueEdgesOffset = 0;\n"
"		float4 uniqueEdgesA[3];\n"
"		\n"
"		uniqueEdgesA[0] = (verticesA[1]-verticesA[0]);\n"
"		uniqueEdgesA[1] = (verticesA[2]-verticesA[1]);\n"
"		uniqueEdgesA[2] = (verticesA[0]-verticesA[2]);\n"
"\n"
"\n"
"		convexPolyhedronA.m_faceOffset = 0;\n"
"                                  \n"
"		float4 normal = make_float4(face.m_plane.x,face.m_plane.y,face.m_plane.z,0.f);\n"
"                             \n"
"		btGpuFace facesA[TRIANGLE_NUM_CONVEX_FACES];\n"
"		int indicesA[3+3+2+2+2];\n"
"		int curUsedIndices=0;\n"
"		int fidx=0;\n"
"\n"
"		//front size of triangle\n"
"		{\n"
"			facesA[fidx].m_indexOffset=curUsedIndices;\n"
"			indicesA[0] = 0;\n"
"			indicesA[1] = 1;\n"
"			indicesA[2] = 2;\n"
"			curUsedIndices+=3;\n"
"			float c = face.m_plane.w;\n"
"			facesA[fidx].m_plane.x = normal.x;\n"
"			facesA[fidx].m_plane.y = normal.y;\n"
"			facesA[fidx].m_plane.z = normal.z;\n"
"			facesA[fidx].m_plane.w = c;\n"
"			facesA[fidx].m_numIndices=3;\n"
"		}\n"
"		fidx++;\n"
"		//back size of triangle\n"
"		{\n"
"			facesA[fidx].m_indexOffset=curUsedIndices;\n"
"			indicesA[3]=2;\n"
"			indicesA[4]=1;\n"
"			indicesA[5]=0;\n"
"			curUsedIndices+=3;\n"
"			float c = dot3F4(normal,verticesA[0]);\n"
"			float c1 = -face.m_plane.w;\n"
"			facesA[fidx].m_plane.x = -normal.x;\n"
"			facesA[fidx].m_plane.y = -normal.y;\n"
"			facesA[fidx].m_plane.z = -normal.z;\n"
"			facesA[fidx].m_plane.w = c;\n"
"			facesA[fidx].m_numIndices=3;\n"
"		}\n"
"		fidx++;\n"
"\n"
"		bool addEdgePlanes = true;\n"
"		if (addEdgePlanes)\n"
"		{\n"
"			int numVertices=3;\n"
"			int prevVertex = numVertices-1;\n"
"			for (int i=0;i<numVertices;i++)\n"
"			{\n"
"				float4 v0 = verticesA[i];\n"
"				float4 v1 = verticesA[prevVertex];\n"
"                                            \n"
"				float4 edgeNormal = normalize(cross(normal,v1-v0));\n"
"				float c = -dot3F4(edgeNormal,v0);\n"
"\n"
"				facesA[fidx].m_numIndices = 2;\n"
"				facesA[fidx].m_indexOffset=curUsedIndices;\n"
"				indicesA[curUsedIndices++]=i;\n"
"				indicesA[curUsedIndices++]=prevVertex;\n"
"                                            \n"
"				facesA[fidx].m_plane.x = edgeNormal.x;\n"
"				facesA[fidx].m_plane.y = edgeNormal.y;\n"
"				facesA[fidx].m_plane.z = edgeNormal.z;\n"
"				facesA[fidx].m_plane.w = c;\n"
"				fidx++;\n"
"				prevVertex = i;\n"
"			}\n"
"		}\n"
"		convexPolyhedronA.m_numFaces = TRIANGLE_NUM_CONVEX_FACES;\n"
"		convexPolyhedronA.m_localCenter = localCenter*(1.f/3.f);\n"
"\n"
"\n"
"		float4 posA = rigidBodies[bodyIndexA].m_pos;\n"
"		posA.w = 0.f;\n"
"		float4 posB = rigidBodies[bodyIndexB].m_pos;\n"
"		posB.w = 0.f;\n"
"		float4 ornA = rigidBodies[bodyIndexA].m_quat;\n"
"		float4 ornB =rigidBodies[bodyIndexB].m_quat;\n"
"\n"
"\n"
"		float4 sepAxis = separatingNormals[i];\n"
"		\n"
"		int shapeTypeB = collidables[collidableIndexB].m_shapeType;\n"
"		if (shapeTypeB==SHAPE_COMPOUND_OF_CONVEX_HULLS)\n"
"		{\n"
"			///////////////////\n"
"			///compound shape support\n"
"			\n"
"			int childShapeIndexB = concavePairsIn[pairIndex].w;\n"
"			int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\n"
"			shapeIndexB = collidables[childColIndexB].m_shapeIndex;\n"
"			float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\n"
"			float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\n"
"			float4 newPosB = transform(&childPosB,&posB,&ornB);\n"
"			float4 newOrnB = qtMul(ornB,childOrnB);\n"
"			posB = newPosB;\n"
"			ornB = newOrnB;\n"
"			\n"
"		}\n"
"		\n"
"		////////////////////////////////////////\n"
"		\n"
"		\n"
"		\n"
"		int numLocalContactsOut = clipHullAgainstHullLocalA(sepAxis,\n"
"														&convexPolyhedronA, &convexShapes[shapeIndexB],\n"
"														posA,ornA,\n"
"													  posB,ornB,\n"
"													  worldVertsB1,worldVertsB2,capacityWorldVerts,\n"
"														minDist, maxDist,\n"
"														&verticesA,&facesA,&indicesA,\n"
"														vertices,faces,indices,\n"
"														localContactsOut,localContactCapacity);\n"
"												\n"
"		if (numLocalContactsOut>0)\n"
"		{\n"
"			float4 normal = -separatingNormals[i];\n"
"			int nPoints = numLocalContactsOut;\n"
"			float4* pointsIn = localContactsOut;\n"
"			int contactIdx[4];// = {-1,-1,-1,-1};\n"
"\n"
"			contactIdx[0] = -1;\n"
"			contactIdx[1] = -1;\n"
"			contactIdx[2] = -1;\n"
"			contactIdx[3] = -1;\n"
"	\n"
"			int nReducedContacts = extractManifoldSequential(pointsIn, nPoints, normal, contactIdx);\n"
"	\n"
"			int dstIdx;\n"
"			AppendInc( nGlobalContactsOut, dstIdx );\n"
"			//if ((dstIdx+nReducedContacts) < capacity)\n"
"			{\n"
"				__global Contact4* c = globalContactsOut+ dstIdx;\n"
"				c->m_worldNormal = normal;\n"
"				c->m_coeffs = (u32)(0.f*0xffff) | ((u32)(0.7f*0xffff)<<16);\n"
"				c->m_batchIdx = pairIndex;\n"
"				int bodyA = concavePairsIn[pairIndex].x;\n"
"				int bodyB = concavePairsIn[pairIndex].y;\n"
"				c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\n"
"				c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\n"
"\n"
"				for (int i=0;i<nReducedContacts;i++)\n"
"				{\n"
"					c->m_worldPos[i] = pointsIn[contactIdx[i]];\n"
"				}\n"
"				GET_NPOINTS(*c) = nReducedContacts;\n"
"			}\n"
"				\n"
"		}//		if (numContactsOut>0)\n"
"	}//	if (i<numPairs)\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"int	findClippingFaces(const float4 separatingNormal,\n"
"                      __global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB,\n"
"                      const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB,\n"
"                       __global float4* worldVertsA1,\n"
"                      __global float4* worldNormalsA1,\n"
"                      __global float4* worldVertsB1,\n"
"                      int capacityWorldVerts,\n"
"                      const float minDist, float maxDist,\n"
"                      __global const float4* vertices,\n"
"                      __global const btGpuFace* faces,\n"
"                      __global const int* indices,\n"
"                      __global int4* clippingFaces, int pairIndex)\n"
"{\n"
"	int numContactsOut = 0;\n"
"	int numWorldVertsB1= 0;\n"
"    \n"
"    \n"
"	int closestFaceB=-1;\n"
"	float dmax = -FLT_MAX;\n"
"    \n"
"	{\n"
"		for(int face=0;face<hullB->m_numFaces;face++)\n"
"		{\n"
"			const float4 Normal = make_float4(faces[hullB->m_faceOffset+face].m_plane.x,\n"
"                                              faces[hullB->m_faceOffset+face].m_plane.y, faces[hullB->m_faceOffset+face].m_plane.z,0.f);\n"
"			const float4 WorldNormal = qtRotate(ornB, Normal);\n"
"			float d = dot3F4(WorldNormal,separatingNormal);\n"
"			if (d > dmax)\n"
"			{\n"
"				dmax = d;\n"
"				closestFaceB = face;\n"
"			}\n"
"		}\n"
"	}\n"
"    \n"
"	{\n"
"		const btGpuFace polyB = faces[hullB->m_faceOffset+closestFaceB];\n"
"		const int numVertices = polyB.m_numIndices;\n"
"		for(int e0=0;e0<numVertices;e0++)\n"
"		{\n"
"			const float4 b = vertices[hullB->m_vertexOffset+indices[polyB.m_indexOffset+e0]];\n"
"			worldVertsB1[pairIndex*capacityWorldVerts+numWorldVertsB1++] = transform(&b,&posB,&ornB);\n"
"		}\n"
"	}\n"
"    \n"
"    int closestFaceA=-1;\n"
"	{\n"
"		float dmin = FLT_MAX;\n"
"		for(int face=0;face<hullA->m_numFaces;face++)\n"
"		{\n"
"			const float4 Normal = make_float4(\n"
"                                              faces[hullA->m_faceOffset+face].m_plane.x,\n"
"                                              faces[hullA->m_faceOffset+face].m_plane.y,\n"
"                                              faces[hullA->m_faceOffset+face].m_plane.z,\n"
"                                              0.f);\n"
"			const float4 faceANormalWS = qtRotate(ornA,Normal);\n"
"            \n"
"			float d = dot3F4(faceANormalWS,separatingNormal);\n"
"			if (d < dmin)\n"
"			{\n"
"				dmin = d;\n"
"				closestFaceA = face;\n"
"                worldNormalsA1[pairIndex] = faceANormalWS;\n"
"			}\n"
"		}\n"
"	}\n"
"    \n"
"    int numVerticesA = faces[hullA->m_faceOffset+closestFaceA].m_numIndices;\n"
"	for(int e0=0;e0<numVerticesA;e0++)\n"
"	{\n"
"        const float4 a = vertices[hullA->m_vertexOffset+indices[faces[hullA->m_faceOffset+closestFaceA].m_indexOffset+e0]];\n"
"        worldVertsA1[pairIndex*capacityWorldVerts+e0] = transform(&a, &posA,&ornA);\n"
"    }\n"
"    \n"
"    clippingFaces[pairIndex].x = closestFaceA;\n"
"    clippingFaces[pairIndex].y = closestFaceB;\n"
"    clippingFaces[pairIndex].z = numVerticesA;\n"
"    clippingFaces[pairIndex].w = numWorldVertsB1;\n"
"    \n"
"    \n"
"	return numContactsOut;\n"
"}\n"
"\n"
"\n"
"\n"
"int clipFaces(__global float4* worldVertsA1,\n"
"              __global float4* worldNormalsA1,\n"
"              __global float4* worldVertsB1,\n"
"              __global float4* worldVertsB2, \n"
"              int capacityWorldVertsB2,\n"
"              const float minDist, float maxDist,\n"
"              __global int4* clippingFaces,\n"
"              int pairIndex)\n"
"{\n"
"	int numContactsOut = 0;\n"
"    \n"
"    int closestFaceA = clippingFaces[pairIndex].x;\n"
"    int closestFaceB = clippingFaces[pairIndex].y;\n"
"	int numVertsInA = clippingFaces[pairIndex].z;\n"
"	int numVertsInB = clippingFaces[pairIndex].w;\n"
"    \n"
"	int numVertsOut = 0;\n"
"    \n"
"	if (closestFaceA<0)\n"
"		return numContactsOut;\n"
"    \n"
"    __global float4* pVtxIn = &worldVertsB1[pairIndex*capacityWorldVertsB2];\n"
"    __global float4* pVtxOut = &worldVertsB2[pairIndex*capacityWorldVertsB2];\n"
"    \n"
"    \n"
"	\n"
"	// clip polygon to back of planes of all faces of hull A that are adjacent to witness face\n"
"    \n"
"	for(int e0=0;e0<numVertsInA;e0++)\n"
"	{\n"
"		const float4 aw = worldVertsA1[pairIndex*capacityWorldVertsB2+e0];\n"
"		const float4 bw = worldVertsA1[pairIndex*capacityWorldVertsB2+((e0+1)%numVertsInA)];\n"
"		const float4 WorldEdge0 = aw - bw;\n"
"		float4 worldPlaneAnormal1 = worldNormalsA1[pairIndex];\n"
"		float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\n"
"		float4 worldA1 = aw;\n"
"		float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\n"
"		float4 planeNormalWS = planeNormalWS1;\n"
"		float planeEqWS=planeEqWS1;\n"
"		numVertsOut = clipFaceGlobal(pVtxIn, numVertsInB, planeNormalWS,planeEqWS, pVtxOut);\n"
"		__global float4* tmp = pVtxOut;\n"
"		pVtxOut = pVtxIn;\n"
"		pVtxIn = tmp;\n"
"		numVertsInB = numVertsOut;\n"
"		numVertsOut = 0;\n"
"	}\n"
"    \n"
"    //float4 planeNormalWS = worldNormalsA1[pairIndex];\n"
"    //float planeEqWS=-dot3F4(planeNormalWS,worldVertsA1[pairIndex*capacityWorldVertsB2]);\n"
"\n"
"\n"
"    \n"
"    /*for (int i=0;i<numVertsInB;i++)\n"
"    {\n"
"        pVtxOut[i] = pVtxIn[i];\n"
"    }*/\n"
"    \n"
"    \n"
"    \n"
"    \n"
"    //numVertsInB=0;\n"
"	\n"
"    float4 planeNormalWS = worldNormalsA1[pairIndex];\n"
"    float planeEqWS=-dot3F4(planeNormalWS,worldVertsA1[pairIndex*capacityWorldVertsB2]);\n"
"\n"
"    for (int i=0;i<numVertsInB;i++)\n"
"    {\n"
"        float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\n"
"        if (depth <=minDist)\n"
"        {\n"
"            depth = minDist;\n"
"        }\n"
"        \n"
"        if (depth <=maxDist)\n"
"        {\n"
"            float4 pointInWorld = pVtxIn[i];\n"
"            pVtxOut[numContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\n"
"        }\n"
"    }\n"
"   \n"
"    clippingFaces[pairIndex].w =numContactsOut;\n"
"   \n"
"    \n"
"	return numContactsOut;\n"
"\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"__kernel void   findClippingFacesKernel(  __global const int2* pairs,\n"
"                                        __global const BodyData* rigidBodies,\n"
"                                        __global const btCollidableGpu* collidables,\n"
"                                        __global const ConvexPolyhedronCL* convexShapes,\n"
"                                        __global const float4* vertices,\n"
"                                        __global const float4* uniqueEdges,\n"
"                                        __global const btGpuFace* faces,\n"
"                                        __global const int* indices,\n"
"                                        __global const float4* separatingNormals,\n"
"                                        __global const int* hasSeparatingAxis,\n"
"                                        __global int4* clippingFacesOut,\n"
"                                        __global float4* worldVertsA1,\n"
"                                        __global float4* worldNormalsA1,\n"
"                                        __global float4* worldVertsB1,\n"
"                                        int capacityWorldVerts,\n"
"                                        int numPairs\n"
"                                        )\n"
"{\n"
"    \n"
"	int i = get_global_id(0);\n"
"	int pairIndex = i;\n"
"    \n"
"	\n"
"	float minDist = -1e30f;\n"
"	float maxDist = 0.02f;\n"
"    \n"
"	if (i<numPairs)\n"
"	{\n"
"        \n"
"		if (hasSeparatingAxis[i])\n"
"		{\n"
"            \n"
"			int bodyIndexA = pairs[i].x;\n"
"			int bodyIndexB = pairs[i].y;\n"
"			\n"
"			int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\n"
"			int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\n"
"			\n"
"			int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\n"
"			int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\n"
"			\n"
"            \n"
"            \n"
"			int numLocalContactsOut = findClippingFaces(separatingNormals[i],\n"
"                                                        &convexShapes[shapeIndexA], &convexShapes[shapeIndexB],\n"
"                                                        rigidBodies[bodyIndexA].m_pos,rigidBodies[bodyIndexA].m_quat,\n"
"                                                        rigidBodies[bodyIndexB].m_pos,rigidBodies[bodyIndexB].m_quat,\n"
"                                                        worldVertsA1,\n"
"                                                        worldNormalsA1,\n"
"                                                        worldVertsB1,capacityWorldVerts,\n"
"                                                        minDist, maxDist,\n"
"                                                        vertices,faces,indices,\n"
"                                                        clippingFacesOut,i);\n"
"            \n"
"            \n"
"		}//		if (hasSeparatingAxis[i])\n"
"	}//	if (i<numPairs)\n"
"    \n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"__kernel void   clipFacesAndContactReductionKernel( __global const int2* pairs,\n"
"                                                   __global const BodyData* rigidBodies,\n"
"                                                   __global const float4* separatingNormals,\n"
"                                                   __global const int* hasSeparatingAxis,\n"
"                                                     __global Contact4* globalContactsOut,\n"
"                                                   __global int4* clippingFacesOut,\n"
"                                                   __global float4* worldVertsA1,\n"
"                                                   __global float4* worldNormalsA1,\n"
"                                                   __global float4* worldVertsB1,\n"
"                                                   __global float4* worldVertsB2,\n"
"                                                   counter32_t nGlobalContactsOut,\n"
"                                                    int vertexFaceCapacity,\n"
"                                                   int numPairs,\n"
"					                                        int debugMode\n"
"                                                   )\n"
"{\n"
"    int i = get_global_id(0);\n"
"	int pairIndex = i;\n"
"	\n"
"    \n"
"	float minDist = -1e30f;\n"
"	float maxDist = 0.02f;\n"
"    \n"
"	if (i<numPairs)\n"
"	{\n"
"        \n"
"		if (hasSeparatingAxis[i])\n"
"		{\n"
"            \n"
"			int bodyIndexA = pairs[i].x;\n"
"			int bodyIndexB = pairs[i].y;\n"
"		    \n"
"            int numLocalContactsOut = 0;\n"
"\n"
"            int capacityWorldVertsB2 = vertexFaceCapacity;\n"
"            \n"
"            __global float4* pVtxIn = &worldVertsB1[pairIndex*capacityWorldVertsB2];\n"
"            __global float4* pVtxOut = &worldVertsB2[pairIndex*capacityWorldVertsB2];\n"
"            \n"
"\n"
"            {\n"
"                __global int4* clippingFaces = clippingFacesOut;\n"
"            \n"
"                \n"
"                int closestFaceA = clippingFaces[pairIndex].x;\n"
"                int closestFaceB = clippingFaces[pairIndex].y;\n"
"                int numVertsInA = clippingFaces[pairIndex].z;\n"
"                int numVertsInB = clippingFaces[pairIndex].w;\n"
"                \n"
"                int numVertsOut = 0;\n"
"                \n"
"                if (closestFaceA>=0)\n"
"                {\n"
"                    \n"
"                    \n"
"                    \n"
"                    // clip polygon to back of planes of all faces of hull A that are adjacent to witness face\n"
"                    \n"
"                    for(int e0=0;e0<numVertsInA;e0++)\n"
"                    {\n"
"                        const float4 aw = worldVertsA1[pairIndex*capacityWorldVertsB2+e0];\n"
"                        const float4 bw = worldVertsA1[pairIndex*capacityWorldVertsB2+((e0+1)%numVertsInA)];\n"
"                        const float4 WorldEdge0 = aw - bw;\n"
"                        float4 worldPlaneAnormal1 = worldNormalsA1[pairIndex];\n"
"                        float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\n"
"                        float4 worldA1 = aw;\n"
"                        float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\n"
"                        float4 planeNormalWS = planeNormalWS1;\n"
"                        float planeEqWS=planeEqWS1;\n"
"                        numVertsOut = clipFaceGlobal(pVtxIn, numVertsInB, planeNormalWS,planeEqWS, pVtxOut);\n"
"                        __global float4* tmp = pVtxOut;\n"
"                        pVtxOut = pVtxIn;\n"
"                        pVtxIn = tmp;\n"
"                        numVertsInB = numVertsOut;\n"
"                        numVertsOut = 0;\n"
"                    }\n"
"                    \n"
"                    float4 planeNormalWS = worldNormalsA1[pairIndex];\n"
"                    float planeEqWS=-dot3F4(planeNormalWS,worldVertsA1[pairIndex*capacityWorldVertsB2]);\n"
"                    \n"
"                    for (int i=0;i<numVertsInB;i++)\n"
"                    {\n"
"                        float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\n"
"                        if (depth <=minDist)\n"
"                        {\n"
"                            depth = minDist;\n"
"                        }\n"
"                        \n"
"                        if (depth <=maxDist)\n"
"                        {\n"
"                            float4 pointInWorld = pVtxIn[i];\n"
"                            pVtxOut[numLocalContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\n"
"                        }\n"
"                    }\n"
"                    \n"
"                }\n"
"                clippingFaces[pairIndex].w =numLocalContactsOut;\n"
"                \n"
"\n"
"            }\n"
"            \n"
"            for (int i=0;i<numLocalContactsOut;i++)\n"
"                pVtxIn[i] = pVtxOut[i];\n"
"                \n"
"		}//		if (hasSeparatingAxis[i])\n"
"	}//	if (i<numPairs)\n"
"    \n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"__kernel void   newContactReductionKernel( __global const int2* pairs,\n"
"                                                   __global const BodyData* rigidBodies,\n"
"                                                   __global const float4* separatingNormals,\n"
"                                                   __global const int* hasSeparatingAxis,\n"
"                                                   __global Contact4* globalContactsOut,\n"
"                                                   __global int4* clippingFaces,\n"
"                                                   __global float4* worldVertsB2,\n"
"                                                   volatile __global int* nGlobalContactsOut,\n"
"                                                   int vertexFaceCapacity,\n"
"                                                   int numPairs\n"
"                                                   )\n"
"{\n"
"    int i = get_global_id(0);\n"
"	int pairIndex = i;\n"
"	\n"
"    int4 contactIdx;\n"
"    contactIdx=make_int4(0,1,2,3);\n"
"    \n"
"	if (i<numPairs)\n"
"	{\n"
"        \n"
"		if (hasSeparatingAxis[i])\n"
"		{\n"
"            \n"
"			\n"
"            \n"
"            \n"
"			int nPoints = clippingFaces[pairIndex].w;\n"
"           \n"
"            if (nPoints>0)\n"
"            {\n"
"\n"
"                 __global float4* pointsIn = &worldVertsB2[pairIndex*vertexFaceCapacity];\n"
"                float4 normal = -separatingNormals[i];\n"
"                \n"
"                int nReducedContacts = extractManifoldSequentialGlobal(pointsIn, nPoints, normal, &contactIdx);\n"
"            \n"
"                int dstIdx;\n"
"                AppendInc( nGlobalContactsOut, dstIdx );\n"
"				\n"
"//#if 0\n"
"                \n"
"				if (dstIdx < numPairs)\n"
"				{\n"
"					__global Contact4* c = &globalContactsOut[dstIdx];\n"
"					c->m_worldNormal = normal;\n"
"					c->m_coeffs = (u32)(0.f*0xffff) | ((u32)(0.7f*0xffff)<<16);\n"
"					c->m_batchIdx = pairIndex;\n"
"					int bodyA = pairs[pairIndex].x;\n"
"					int bodyB = pairs[pairIndex].y;\n"
"					c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\n"
"					c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\n"
"                    \n"
"                    switch (nReducedContacts)\n"
"                    {\n"
"                        case 4:\n"
"                            c->m_worldPos[3] = pointsIn[contactIdx.w];\n"
"                        case 3:\n"
"                            c->m_worldPos[2] = pointsIn[contactIdx.z];\n"
"                        case 2:\n"
"                            c->m_worldPos[1] = pointsIn[contactIdx.y];\n"
"                        case 1:\n"
"                            c->m_worldPos[0] = pointsIn[contactIdx.x];\n"
"                        default:\n"
"                        {\n"
"                        }\n"
"                    };\n"
"                    \n"
"					GET_NPOINTS(*c) = nReducedContacts;\n"
"                    \n"
"                 }\n"
"                 \n"
"                \n"
"//#endif\n"
"				\n"
"			}//		if (numContactsOut>0)\n"
"		}//		if (hasSeparatingAxis[i])\n"
"	}//	if (i<numPairs)\n"
"\n"
"    \n"
"    \n"
"}\n"
"\n"
;
