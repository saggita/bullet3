//this file is autogenerated using stringify.bat (premake --stringify) in the build folder of this project
static const char* SoftBodyKernals= \
"ï»¿//#pragma OPENCL EXTENSION cl_amd_printf : enable\n\n"
"\n"
"// From MathCl.h\n"
"typedef unsigned int u32;\n"
"typedef unsigned short u16;\n"
"typedef unsigned char u8;\n"
"\n"
"\n"
"typedef struct \n"
"{\n"
"	float4 m_Pos;\n"
"	float4 m_PosNext;\n"
"	float4 m_Vel;	\n"
"	float4 m_Accel;\n"
"\n"
"	float4 m_AABBMin;\n"
"	float4 m_AABBMax;\n"
"\n"
"	float m_InvMass;\n"
"	u32 m_Index; // local index. Only unique inside the cloth which it belongs to.\n"
"	u32 m_IndexGlobal; // global index\n"
"	u32 m_PinIndex; // if no pin is attached, -1. \n"
"	u32 m_ClothIndex;\n"
"} VertexClothData;\n"
"\n"
"typedef struct \n"
"{\n"
"	u32 m_Index; // local index. Only unique inside the cloth which it belongs to.\n"
"	u32 m_IndexGlobal; // global index\n"
"	u32 m_IndexGlobalVrx0; // global vertex index\n"
"	u32 m_IndexGlobalVrx1; // global vertex index\n"
"\n"
"	float4 m_RestLength;\n"
"\n"
"	u32 m_ClothIndex;\n"
"} SpringClothData;\n"
"\n"
"typedef struct \n"
"{\n"
"	u32 m_Index;\n"
"	float4 m_Pos;\n"
"} SoftBodyLink;\n"
"\n"
"\n"
"typedef struct \n"
"{\n"
"	u32 m_Index;\n"
"	u32 m_NumVertices;\n"
"	u32 m_NumStretchSprings;\n"
"	u32 m_NumBendingSprings;\n"
"	\n"
"	float4 m_AABBMin;\n"
"	float4 m_AABBMax;\n"
"\n"
"	u32 m_OffsetVertices;\n"
"	u32 m_OffsetStretchSprings;\n"
"	u32 m_OffsetBendingSprings;\n"
"\n"
"	float m_Margin;\n"
"	float m_Ks;\n"
"	float m_Kb;\n"
"} ClothInfoData;\n"
"\n"
"///keep this in sync with btCollidable.h\n"
"typedef struct\n"
"{\n"
"	int m_shapeType;\n"
"	int m_shapeIndex;\n"
"	\n"
"} btCollidableGpu;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_pos;\n"
"	float4 m_quat;\n"
"	float4 m_linVel;\n"
"	float4 m_angVel;\n"
"\n"
"	u32 m_collidableIdx;	\n"
"	float m_invMass;\n"
"	float m_restituitionCoeff;\n"
"	float m_frictionCoeff;\n"
"} BodyData;\n"
"\n"
"\n"
"typedef struct  \n"
"{\n"
"	float4		m_localCenter;\n"
"	float4		m_extents;\n"
"	float4		mC;\n"
"	float4		mE;\n"
"	\n"
"	float			m_radius;\n"
"	int	m_faceOffset;\n"
"	int m_numFaces;\n"
"	int	m_numVertices;\n"
"	\n"
"	int m_vertexOffset;\n"
"	int	m_uniqueEdgesOffset;\n"
"	int	m_numUniqueEdges;\n"
"	int m_unused;\n"
"\n"
"} ConvexPolyhedronCL;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_plane;\n"
"	int m_indexOffset;\n"
"	int m_numIndices;\n"
"} btGpuFace;\n"
"\n"
"typedef struct \n"
"{\n"
"	union\n"
"	{\n"
"		float4	m_min;\n"
"		float   m_minElems[4];\n"
"		int			m_minIndices[4];\n"
"	};\n"
"	union\n"
"	{\n"
"		float4	m_max;\n"
"		float   m_maxElems[4];\n"
"		int			m_maxIndices[4];\n"
"	};\n"
"} btAabbCL;\n"
"\n"
"__inline\n"
"float dot3F4(float4 a, float4 b)\n"
"{\n"
"	float4 a1 = (float4)(a.xyz,0.f);\n"
"	float4 b1 = (float4)(b.xyz,0.f);\n"
"	return dot(a1, b1);\n"
"}\n"
"\n"
"__inline\n"
"float4 cross3(float4 a, float4 b)\n"
"{\n"
"	return cross(a,b);\n"
"}\n"
"\n"
"\n"
"__inline\n"
"float4 fastNormalize4(float4 v)\n"
"{\n"
"	return fast_normalize(v);\n"
"}\n"
"\n"
"\n"
"///////////////////////////////////////\n"
"//	Quaternion\n"
"///////////////////////////////////////\n"
"\n"
"typedef float4 Quaternion;\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b);\n"
"\n"
"__inline\n"
"Quaternion qtNormalize(Quaternion in);\n"
"\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec);\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q);\n"
"\n"
"\n"
"\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b)\n"
"{\n"
"	Quaternion ans;\n"
"	ans = cross3( a, b );\n"
"	ans += a.w*b+b.w*a;\n"
"//	ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\n"
"	ans.w = a.w*b.w - dot3F4(a, b);\n"
"	return ans;\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtNormalize(Quaternion in)\n"
"{\n"
"	return fastNormalize4(in);\n"
"//	in /= length( in );\n"
"//	return in;\n"
"}\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec)\n"
"{\n"
"	Quaternion qInv = qtInvert( q );\n"
"	float4 vcpy = vec;\n"
"	vcpy.w = 0.f;\n"
"	float4 out = qtMul(qtMul(q,vcpy),qInv);\n"
"	return out;\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q)\n"
"{\n"
"	return (Quaternion)(-q.xyz, q.w);\n"
"}\n"
"\n"
"__inline\n"
"float4 qtInvRotate(const Quaternion q, float4 vec)\n"
"{\n"
"	return qtRotate( qtInvert( q ), vec );\n"
"}\n"
"\n"
"__inline\n"
"float4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\n"
"{\n"
"	return qtRotate( *orientation, *p ) + (*translation);\n"
"}\n"
"\n"
"\n"
"\n"
"__inline\n"
"float4 normalize3(const float4 a)\n"
"{\n"
"	float4 n = (float4)(a.x, a.y, a.z, 0.f);\n"
"	return fastNormalize4( n );\n"
"}\n"
"\n"
"__kernel \n"
"void ClearForcesKernel(const u32 numVertices, const float dt, __global VertexClothData* gVertexClothData)\n"
"{\n"
"	u32 vertexID = get_global_id(0);\n"
"\n"
"	if( vertexID < numVertices )\n"
"	{		\n"
"		VertexClothData vertexData = gVertexClothData[vertexID];\n"
"		vertexData.m_Accel = (float4)(0.f, 0.f, 0.f, 0.f);\n"
"		gVertexClothData[vertexID] = vertexData;\n"
"	}\n"
"}\n"
"\n"
"__kernel \n"
"void ComputeNextVertexPositionsKernel(const u32 numVertices, const float dt, __global VertexClothData* gVertexClothData)\n"
"{\n"
"	u32 vertexID = get_global_id(0);\n"
"\n"
"	if( vertexID < numVertices )\n"
"	{		\n"
"		VertexClothData vertexData = gVertexClothData[vertexID];	\n"
"		vertexData.m_PosNext = vertexData.m_Pos + vertexData.m_Vel * dt;\n"
"		gVertexClothData[vertexID] = vertexData;\n"
"	}\n"
"}\n"
"\n"
"__kernel \n"
"void ApplyGravityKernel(const u32 numVertices, const float4 gravity, const float dt, __global VertexClothData* gVertexClothData)\n"
"{\n"
"	u32 vertexID = get_global_id(0);\n"
"\n"
"	if( vertexID < numVertices )\n"
"	{		\n"
"		VertexClothData vertexData = gVertexClothData[vertexID];\n"
"		vertexData.m_Accel += gravity;\n"
"		gVertexClothData[vertexID] = vertexData;\n"
"	}\n"
"}\n"
"\n"
"__kernel \n"
"void ApplyForcesKernel(const u32 numVertices, const float dt, __global VertexClothData* gVertexClothData)\n"
"{\n"
"	u32 vertexID = get_global_id(0);\n"
"\n"
"	if( vertexID < numVertices )\n"
"	{		\n"
"		VertexClothData vertexData = gVertexClothData[vertexID];\n"
"\n"
"		if ( vertexData.m_InvMass > 0 )\n"
"		{\n"
"			vertexData.m_Vel += vertexData.m_Accel * dt;\n"
"			gVertexClothData[vertexID] = vertexData;		\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"// springType - 0 for stretch and 1 for bending\n"
"__kernel \n"
"void EnforceEdgeConstraintsKernel(const u32 numSpringsInBatch, const u32 startSpringIndex, const float dt, const int springType, __global ClothInfoData* gClothInfoData, __global VertexClothData* gVertexClothData, __global SpringClothData* gSpringClothData)\n"
"{\n"
"	u32 springID = get_global_id(0) + startSpringIndex;\n"
"\n"
"	if( get_global_id(0) < numSpringsInBatch )\n"
"	{\n"
"		SpringClothData springData = gSpringClothData[springID];\n"
"\n"
"		u32 indexVrx0 = springData.m_IndexGlobalVrx0;\n"
"		u32 indexVrx1 = springData.m_IndexGlobalVrx1;\n"
"\n"
"		VertexClothData vertexData0 = gVertexClothData[indexVrx0];\n"
"		VertexClothData vertexData1 = gVertexClothData[indexVrx1];\n"
"\n"
"		float Kstiff = 0;\n"
"\n"
"		if ( springType == 0 ) // stretch\n"
"			Kstiff = gClothInfoData[springData.m_ClothIndex].m_Ks;\n"
"		else if ( springType == 1 ) // bending\n"
"			Kstiff = gClothInfoData[springData.m_ClothIndex].m_Kb;\n"
"		\n"
"		float4 vecNewSpring = vertexData0.m_PosNext - vertexData1.m_PosNext;\n"
"		vecNewSpring.w = 0;\n"
"\n"
"		float newLen = length(vecNewSpring);\n"
"		float4 restLen = springData.m_RestLength;\n"
"		\n"
"		if ( (vertexData0.m_InvMass + vertexData1.m_InvMass) > 0 )\n"
"		{\n"
"			float4 cji = (newLen-restLen.x)*normalize(vecNewSpring) / (vertexData0.m_InvMass + vertexData1.m_InvMass);\n"
"			\n"
"			float4 dVert0;\n"
"			float4 dVert1;\n"
"\n"
"			dVert0 = -Kstiff * cji * vertexData0.m_InvMass;\n"
"			dVert1 = Kstiff * cji * vertexData1.m_InvMass;\n"
"		\n"
"			vertexData0.m_PosNext += dVert0;\n"
"			vertexData1.m_PosNext += dVert1;\n"
"\n"
"			gVertexClothData[indexVrx0] = vertexData0; \n"
"			gVertexClothData[indexVrx1] = vertexData1;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"__kernel \n"
"void UpdateVelocitiesKernel(const u32 numVertices, const float dt, __global VertexClothData* gVertexClothData)\n"
"{\n"
"	u32 vertexID = get_global_id(0);\n"
"\n"
"	if( vertexID < numVertices )\n"
"	{		\n"
"		VertexClothData vertexData = gVertexClothData[vertexID];\n"
"\n"
"		if ( vertexData.m_InvMass > 0 )\n"
"		{\n"
"			vertexData.m_Vel = (vertexData.m_PosNext - vertexData.m_Pos)/dt;\n"
"			gVertexClothData[vertexID] = vertexData;		\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"__kernel \n"
"void AdvancePositionKernel(const u32 numVertices, const float dt, __global VertexClothData* gVertexClothData)\n"
"{\n"
"	u32 vertexID = get_global_id(0);\n"
"\n"
"	if( vertexID < numVertices )\n"
"	{		\n"
"		VertexClothData vertexData = gVertexClothData[vertexID];\n"
"		vertexData.m_Pos = vertexData.m_Pos + vertexData.m_Vel * dt;\n"
"		gVertexClothData[vertexID] = vertexData;\n"
"	}\n"
"}\n"
"\n"
"__kernel \n"
"void UpdateVertexBoundingVolumeKernel(const u32 numVertices, const float dt, __global VertexClothData* gVertexClothData, __global ClothInfoData* gClothInfoData)\n"
"{\n"
"	u32 vertexID = get_global_id(0);\n"
"\n"
"	if( vertexID < numVertices )\n"
"	{	\n"
"		VertexClothData vertexData = gVertexClothData[vertexID];\n"
"\n"
"		const float margin = gClothInfoData[vertexData.m_ClothIndex].m_Margin;\n"
"		float4 newPos = vertexData.m_Pos + vertexData.m_Vel * dt;\n"
"		\n"
"		vertexData.m_AABBMin = vertexData.m_Pos;\n"
"		vertexData.m_AABBMax = vertexData.m_Pos;\n"
"\n"
"		vertexData.m_AABBMin.x = min(vertexData.m_AABBMin.x, newPos.x) - margin;\n"
"		vertexData.m_AABBMin.y = min(vertexData.m_AABBMin.y, newPos.y) - margin;\n"
"		vertexData.m_AABBMin.z = min(vertexData.m_AABBMin.z, newPos.z) - margin;\n"
"\n"
"		vertexData.m_AABBMax.x = max(vertexData.m_AABBMax.x, newPos.x) + margin;\n"
"		vertexData.m_AABBMax.y = max(vertexData.m_AABBMax.y, newPos.y) + margin;\n"
"		vertexData.m_AABBMax.z = max(vertexData.m_AABBMax.z, newPos.z) + margin;\n"
"		\n"
"		gVertexClothData[vertexID] = vertexData;\n"
"	}\n"
"}\n"
"\n"
"// TODO:Should be parallel in cloth node level.\n"
"__kernel \n"
"void UpdateClothBoundingVolumeKernel(const u32 numClothes, __global ClothInfoData* gClothInfoData, __global VertexClothData* gVertexClothData)\n"
"{\n"
"	u32 clothID = get_global_id(0);\n"
"\n"
"	if( clothID < numClothes )\n"
"	{	\n"
"		ClothInfoData clothInfo = gClothInfoData[clothID];\n"
"		u32 numVertices = clothInfo.m_NumVertices;\n"
"\n"
"		clothInfo.m_AABBMin.x = 100000000.0f;\n"
"		clothInfo.m_AABBMin.y = 100000000.0f;\n"
"		clothInfo.m_AABBMin.z = 100000000.0f;\n"
"\n"
"		clothInfo.m_AABBMax.x = -100000000.0f;\n"
"		clothInfo.m_AABBMax.y = -100000000.0f;\n"
"		clothInfo.m_AABBMax.z = -100000000.0f;\n"
"\n"
"		for ( int vertexID = 0; vertexID < numVertices; vertexID++ )\n"
"		{\n"
"			VertexClothData vertexData = gVertexClothData[vertexID];\n"
"			\n"
"			/*if ( vertexID == 0 )\n"
"			{\n"
"				clothInfo.m_AABBMin = vertexData.m_AABBMin;\n"
"				clothInfo.m_AABBMax = vertexData.m_AABBMax;\n"
"			}\n"
"			else*/\n"
"			{\n"
"				clothInfo.m_AABBMin.x = min(clothInfo.m_AABBMin.x, vertexData.m_AABBMin.x);\n"
"				clothInfo.m_AABBMin.y = min(clothInfo.m_AABBMin.y, vertexData.m_AABBMin.y);\n"
"				clothInfo.m_AABBMin.z = min(clothInfo.m_AABBMin.z, vertexData.m_AABBMin.z);\n"
"\n"
"				clothInfo.m_AABBMax.x = max(clothInfo.m_AABBMax.x, vertexData.m_AABBMax.x);\n"
"				clothInfo.m_AABBMax.y = max(clothInfo.m_AABBMax.y, vertexData.m_AABBMax.y);\n"
"				clothInfo.m_AABBMax.z = max(clothInfo.m_AABBMax.z, vertexData.m_AABBMax.z);\n"
"			}\n"
"		}\n"
"\n"
"		gClothInfoData[clothID] = clothInfo;\n"
"	}\n"
"}\n"
"\n"
"// Assumes planeEqn[0], planeEqn[1] and planeEqn[2] forms unit normal vector.\n"
"float signedDistanceFromPointToPlane(float4 point, float4 planeEqn, float4* closestPointOnFace)\n"
"{\n"
"	float4 n = (float4)(planeEqn.x, planeEqn.y, planeEqn.z, 0);\n"
"\n"
"	if ( length(n) < 1e-6 )\n"
"		return 0;\n"
"\n"
"	if ( point.x == 0 && point.y == 0 && point.z == 0 )\n"
"	{\n"
"		float dist = planeEqn.w;\n"
"\n"
"		if ( closestPointOnFace )\n"
"			*closestPointOnFace = - dist * n;\n"
"\n"
"		return dist;\n"
"	}\n"
"	else\n"
"	{\n"
"		float dist = dot3F4(n, point) + planeEqn.w;\n"
"\n"
"		if ( closestPointOnFace )\n"
"			*closestPointOnFace = point - dist * n;\n"
"\n"
"		return dist;\n"
"	}\n"
"}\n"
"\n"
"__kernel \n"
"void ResolveCollisionKernel(const u32 numSoftbodyVertices, \n"
"							const float dt, \n"
"							__global VertexClothData* gVertexClothData,\n"
"							__global const BodyData* rigidBodies, \n"
"							const u32 numRigidBodies,\n"
"							__global const btCollidableGpu* collidables,\n"
"							__global const ConvexPolyhedronCL* convexShapes, \n"
"							__global const btGpuFace* faces,\n"
"							__global const int* convexIndices, \n"
"							__global const float4* convexVertices)\n"
"{\n"
"	u32 vertexID = get_global_id(0);\n"
"\n"
"	if( vertexID < numSoftbodyVertices )\n"
"	{		\n"
"		float margin = 0.3f;\n"
"\n"
"		VertexClothData vertexData = gVertexClothData[vertexID];\n"
"		\n"
"		for ( u32 i = 0; i < numRigidBodies; i++ )\n"
"		{\n"
"			float4 pos = rigidBodies[i].m_pos;\n"
"			float4 quat = rigidBodies[i].m_quat;\n"
"\n"
"			int collidableIndex = rigidBodies[i].m_collidableIdx;\n"
"			int shapeIndex = collidables[collidableIndex].m_shapeIndex;\n"
"			int numFaces = convexShapes[shapeIndex].m_numFaces;\n"
"			float4 closestPnt = (float4)(0, 0, 0, 0);\n"
"			float minDist = -1000000.f; // TODO: What is the largest/smallest float?\n"
"			bool bCollide = true;\n"
"\n"
"			for ( int f = 0; f < numFaces; f++ )\n"
"			{\n"
"				btGpuFace face = faces[convexShapes[shapeIndex].m_faceOffset+f];\n"
"\n"
"				// set up a plane equation \n"
"				float4 planeEqn;\n"
"				float4 n = qtRotate(quat, (float4)(face.m_plane.xyz, 0));\n"
"				planeEqn.xyz = n.xyz;\n"
"\n"
"				float4 vertInFace = convexVertices[convexShapes[shapeIndex].m_vertexOffset + convexIndices[face.m_indexOffset + 0]];\n"
"				vertInFace = transform(&vertInFace, &pos, &quat);\n"
"				planeEqn.w = -dot3F4(n, vertInFace) - margin;\n"
"\n"
"				// compute a signed distance from the vertex in cloth to the face of rigidbody.\n"
"				float4 pntReturn;\n"
"				float dist = signedDistanceFromPointToPlane(vertexData.m_PosNext, planeEqn, &pntReturn);\n"
"\n"
"				// If the distance is positive, the plane is a separating plane. \n"
"				if ( dist > 0 )\n"
"				{\n"
"					bCollide = false;\n"
"					break;\n"
"				}\n"
"\n"
"				if ( dist > minDist )\n"
"				{\n"
"					minDist = dist;\n"
"					closestPnt = pntReturn;\n"
"				}\n"
"			}\n"
"				\n"
"			// If there is a collision\n"
"			if ( bCollide )\n"
"			{\n"
"				vertexData.m_Pos = closestPnt;\n"
"				vertexData.m_PosNext = vertexData.m_Pos;\n"
"				vertexData.m_Vel = (float4)(0, 0, 0, 0); // TODO: the velocity should be the one from the closest point.\n"
"			}\n"
"		}\n"
"\n"
"		gVertexClothData[vertexID] = vertexData;		\n"
"	}\n"
"}\n"
"\n"
;
